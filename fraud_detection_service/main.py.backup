from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import List, Optional
import joblib
import numpy as np
import json
from pathlib import Path
import os

app = FastAPI(
    title="Fraud Detection Service",
    description="Service de detection de fraude en temps reel",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

MODEL_DIR = Path("/app/ml_model/models")
if not MODEL_DIR.exists():
    MODEL_DIR = Path(__file__).parent.parent / "ml_model" / "models"

MODEL_PATH_RF = MODEL_DIR / "random_forest_model.pkl"
MODEL_PATH_IF = MODEL_DIR / "isolation_forest_model.pkl"
SCALER_PATH = MODEL_DIR / "scaler.pkl"
FEATURES_PATH = MODEL_DIR / "feature_columns.json"

model = None
scaler = None
feature_columns = None
model_type = None
FRAUD_THRESHOLD = float(os.getenv("FRAUD_THRESHOLD", "0.2"))  # ✅ CHANGÉ DE 0.5 À 0.2

class TransactionFeatures(BaseModel):
    V1: float
    V2: float
    V3: float
    V4: float
    V5: float
    V6: float
    V7: float
    V8: float
    V9: float
    V10: float
    V11: float
    V12: float
    V13: float
    V14: float
    V15: float
    V16: float
    V17: float
    V18: float
    V19: float
    V20: float
    V21: float
    V22: float
    V23: float
    V24: float
    V25: float
    V26: float
    V27: float
    V28: float
    Amount: float

class TransactionRequest(BaseModel):
    transaction_id: str
    features: TransactionFeatures

class SimpleTransactionRequest(BaseModel):
    amount: float
    merchant: str
    category: Optional[str] = "Other"
    user_id: Optional[str] = None
    timestamp: Optional[str] = None

class FraudDetectionResponse(BaseModel):
    transaction_id: Optional[str] = None
    is_fraud: bool
    fraud_score: float
    confidence: float

def generate_synthetic_features(amount: float, merchant: str, category: str):
    np.random.seed(int(amount * 1000) % 10000 + len(merchant))
    features = {}
    for i in range(1, 29):
        if i in [1, 2, 3, 4, 5]:
            features[f'V{i}'] = float(np.random.normal(0, 1))
        elif i in [6, 7, 8, 9, 10]:
            features[f'V{i}'] = float(np.random.normal(0, 2))
        else:
            features[f'V{i}'] = float(np.random.normal(0, 1.5))
    if amount > 1000:
        features['V11'] = float(np.random.normal(2, 1))
        features['V12'] = float(np.random.normal(-1, 1))
        features['V14'] = float(np.random.normal(-2, 0.8))
    if amount > 5000:
        features['V4'] = float(np.random.normal(3, 1))
        features['V11'] = float(np.random.normal(3.5, 0.5))
        features['V14'] = float(np.random.normal(-3, 0.5))
    features['Amount'] = float(amount)
    return features

def load_model():
    global model, scaler, feature_columns, model_type
    if model is None:
        model_path = None
        if MODEL_PATH_RF.exists():
            model_path = MODEL_PATH_RF
            model_type = 'random_forest'
            print(f"Chargement du modele Random Forest...")
        elif MODEL_PATH_IF.exists():
            model_path = MODEL_PATH_IF
            model_type = 'isolation_forest'
            print(f"Chargement du modele Isolation Forest...")
        else:
            raise FileNotFoundError(f"Aucun modele trouve dans {MODEL_DIR}")
        model = joblib.load(model_path)
        print(f"Modele charge: {type(model).__name__}")
        if SCALER_PATH.exists():
            scaler = joblib.load(SCALER_PATH)
            print(f"Scaler charge")
        else:
            scaler = None
            print(f"Scaler non trouve")
        if FEATURES_PATH.exists():
            with open(FEATURES_PATH, 'r') as f:
                feature_columns = json.load(f)
            print(f"Features: {len(feature_columns)} colonnes")
        else:
            feature_columns = [f'V{i+1}' for i in range(28)] + ['Amount']
            print(f"Features par defaut: {len(feature_columns)} colonnes")
        print(f"Service ML pret - Type: {model_type}, Seuil: {FRAUD_THRESHOLD}")

@app.on_event("startup")
async def startup_event():
    load_model()

@app.get("/")
async def root():
    return {
        "service": "Fraud Detection Service",
        "status": "running",
        "model_loaded": model is not None,
        "model_type": model_type
    }

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "model_loaded": model is not None
    }

@app.post("/predict", response_model=FraudDetectionResponse)
async def predict_fraud(transaction: SimpleTransactionRequest):
    print(f"predict appele - amount={transaction.amount}, merchant={transaction.merchant}")
    if model is None:
        raise HTTPException(status_code=503, detail="Modele non charge")
    try:
        features = generate_synthetic_features(transaction.amount, transaction.merchant, transaction.category or "Other")
        print(f"Features generees: Amount={features['Amount']}, V11={features['V11']:.2f}")
        feature_values = [features[col] for col in feature_columns]
        feature_array = np.array(feature_values, dtype=np.float32).reshape(1, -1)
        if not np.isfinite(feature_array).all():
            raise ValueError("Features contiennent des valeurs infinies ou NaN")
        if scaler is not None:
            feature_scaled = scaler.transform(feature_array)
            feature_scaled = np.array(feature_scaled, dtype=np.float32)
        else:
            feature_scaled = feature_array
        if model_type == 'random_forest':
            prediction = model.predict(feature_scaled)[0]
            if hasattr(model, 'predict_proba'):
                proba = model.predict_proba(feature_scaled)[0]
                fraud_probability = float(proba[1]) if len(proba) > 1 else float(proba[0])
                confidence = fraud_probability
                fraud_score = fraud_probability
                is_fraud = fraud_probability >= FRAUD_THRESHOLD
            else:
                is_fraud = bool(prediction == 1)
                fraud_score = 1.0 if is_fraud else 0.0
                confidence = fraud_score
        else:
            prediction = model.predict(feature_scaled)[0]
            is_fraud = prediction == -1
            if hasattr(model, 'score_samples'):
                score = model.score_samples(feature_scaled)[0]
                fraud_score = float(score)
                confidence = abs(fraud_score) / 10.0
                confidence = min(confidence, 1.0)
            else:
                fraud_score = -1.0 if is_fraud else 1.0
                confidence = 0.8 if is_fraud else 0.2
        emoji = "FRAUDE" if is_fraud else "OK"
        print(f"{emoji} Resultat: is_fraud={is_fraud}, score={fraud_score:.4f}")
        return FraudDetectionResponse(
            is_fraud=is_fraud,
            fraud_score=fraud_score,
            confidence=confidence
        )
    except Exception as e:
        import traceback
        print(f"Erreur ML: {str(e)}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Erreur ML: {str(e)}")

@app.post("/detect", response_model=FraudDetectionResponse)
async def detect_fraud(transaction: TransactionRequest):
    print(f"detect appele - transaction_id={transaction.transaction_id}")
    if model is None:
        raise HTTPException(status_code=503, detail="Modele non charge")
    try:
        feature_dict = transaction.features.dict()
        feature_values = [feature_dict[col] for col in feature_columns]
        feature_array = np.array(feature_values, dtype=np.float32).reshape(1, -1)
        if scaler is not None:
            feature_scaled = scaler.transform(feature_array)
        else:
            feature_scaled = feature_array
        if model_type == 'random_forest':
            prediction = model.predict(feature_scaled)[0]
            if hasattr(model, 'predict_proba'):
                proba = model.predict_proba(feature_scaled)[0]
                fraud_probability = float(proba[1]) if len(proba) > 1 else float(proba[0])
                is_fraud = fraud_probability >= FRAUD_THRESHOLD
                fraud_score = fraud_probability
                confidence = fraud_probability
            else:
                is_fraud = bool(prediction == 1)
                fraud_score = 1.0 if is_fraud else 0.0
                confidence = fraud_score
        else:
            prediction = model.predict(feature_scaled)[0]
            is_fraud = prediction == -1
            fraud_score = -1.0 if is_fraud else 1.0
            confidence = 0.8 if is_fraud else 0.2
        return FraudDetectionResponse(
            transaction_id=transaction.transaction_id,
            is_fraud=is_fraud,
            fraud_score=fraud_score,
            confidence=confidence
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)